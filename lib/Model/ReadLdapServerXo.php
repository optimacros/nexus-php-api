<?php
/**
 * ReadLdapServerXo
 *
 * PHP version 5
 *
 * @category Class
 * @package  Optimacros\NexusPhpApi
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Nexus Repository Manager REST API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 3.43.0-01
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.29
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Optimacros\NexusPhpApi\Model;

use \ArrayAccess;
use \Optimacros\NexusPhpApi\ObjectSerializer;

/**
 * ReadLdapServerXo Class Doc Comment
 *
 * @category Class
 * @package  Optimacros\NexusPhpApi
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ReadLdapServerXo implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'ReadLdapServerXo';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'name' => 'string',
        'protocol' => 'string',
        'useTrustStore' => 'bool',
        'host' => 'string',
        'port' => 'int',
        'searchBase' => 'string',
        'authScheme' => 'string',
        'authRealm' => 'string',
        'authUsername' => 'string',
        'connectionTimeoutSeconds' => 'int',
        'connectionRetryDelaySeconds' => 'int',
        'maxIncidentsCount' => 'int',
        'userBaseDn' => 'string',
        'userSubtree' => 'bool',
        'userObjectClass' => 'string',
        'userLdapFilter' => 'string',
        'userIdAttribute' => 'string',
        'userRealNameAttribute' => 'string',
        'userEmailAddressAttribute' => 'string',
        'userPasswordAttribute' => 'string',
        'ldapGroupsAsRoles' => 'bool',
        'groupType' => 'string',
        'groupBaseDn' => 'string',
        'groupSubtree' => 'bool',
        'groupObjectClass' => 'string',
        'groupIdAttribute' => 'string',
        'groupMemberAttribute' => 'string',
        'groupMemberFormat' => 'string',
        'userMemberOfAttribute' => 'string',
        'id' => 'string',
        'order' => 'int'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'name' => null,
        'protocol' => null,
        'useTrustStore' => null,
        'host' => null,
        'port' => 'int32',
        'searchBase' => null,
        'authScheme' => null,
        'authRealm' => null,
        'authUsername' => null,
        'connectionTimeoutSeconds' => 'int32',
        'connectionRetryDelaySeconds' => 'int32',
        'maxIncidentsCount' => 'int32',
        'userBaseDn' => null,
        'userSubtree' => null,
        'userObjectClass' => null,
        'userLdapFilter' => null,
        'userIdAttribute' => null,
        'userRealNameAttribute' => null,
        'userEmailAddressAttribute' => null,
        'userPasswordAttribute' => null,
        'ldapGroupsAsRoles' => null,
        'groupType' => null,
        'groupBaseDn' => null,
        'groupSubtree' => null,
        'groupObjectClass' => null,
        'groupIdAttribute' => null,
        'groupMemberAttribute' => null,
        'groupMemberFormat' => null,
        'userMemberOfAttribute' => null,
        'id' => null,
        'order' => 'int32'
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'name' => 'name',
        'protocol' => 'protocol',
        'useTrustStore' => 'useTrustStore',
        'host' => 'host',
        'port' => 'port',
        'searchBase' => 'searchBase',
        'authScheme' => 'authScheme',
        'authRealm' => 'authRealm',
        'authUsername' => 'authUsername',
        'connectionTimeoutSeconds' => 'connectionTimeoutSeconds',
        'connectionRetryDelaySeconds' => 'connectionRetryDelaySeconds',
        'maxIncidentsCount' => 'maxIncidentsCount',
        'userBaseDn' => 'userBaseDn',
        'userSubtree' => 'userSubtree',
        'userObjectClass' => 'userObjectClass',
        'userLdapFilter' => 'userLdapFilter',
        'userIdAttribute' => 'userIdAttribute',
        'userRealNameAttribute' => 'userRealNameAttribute',
        'userEmailAddressAttribute' => 'userEmailAddressAttribute',
        'userPasswordAttribute' => 'userPasswordAttribute',
        'ldapGroupsAsRoles' => 'ldapGroupsAsRoles',
        'groupType' => 'groupType',
        'groupBaseDn' => 'groupBaseDn',
        'groupSubtree' => 'groupSubtree',
        'groupObjectClass' => 'groupObjectClass',
        'groupIdAttribute' => 'groupIdAttribute',
        'groupMemberAttribute' => 'groupMemberAttribute',
        'groupMemberFormat' => 'groupMemberFormat',
        'userMemberOfAttribute' => 'userMemberOfAttribute',
        'id' => 'id',
        'order' => 'order'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'name' => 'setName',
        'protocol' => 'setProtocol',
        'useTrustStore' => 'setUseTrustStore',
        'host' => 'setHost',
        'port' => 'setPort',
        'searchBase' => 'setSearchBase',
        'authScheme' => 'setAuthScheme',
        'authRealm' => 'setAuthRealm',
        'authUsername' => 'setAuthUsername',
        'connectionTimeoutSeconds' => 'setConnectionTimeoutSeconds',
        'connectionRetryDelaySeconds' => 'setConnectionRetryDelaySeconds',
        'maxIncidentsCount' => 'setMaxIncidentsCount',
        'userBaseDn' => 'setUserBaseDn',
        'userSubtree' => 'setUserSubtree',
        'userObjectClass' => 'setUserObjectClass',
        'userLdapFilter' => 'setUserLdapFilter',
        'userIdAttribute' => 'setUserIdAttribute',
        'userRealNameAttribute' => 'setUserRealNameAttribute',
        'userEmailAddressAttribute' => 'setUserEmailAddressAttribute',
        'userPasswordAttribute' => 'setUserPasswordAttribute',
        'ldapGroupsAsRoles' => 'setLdapGroupsAsRoles',
        'groupType' => 'setGroupType',
        'groupBaseDn' => 'setGroupBaseDn',
        'groupSubtree' => 'setGroupSubtree',
        'groupObjectClass' => 'setGroupObjectClass',
        'groupIdAttribute' => 'setGroupIdAttribute',
        'groupMemberAttribute' => 'setGroupMemberAttribute',
        'groupMemberFormat' => 'setGroupMemberFormat',
        'userMemberOfAttribute' => 'setUserMemberOfAttribute',
        'id' => 'setId',
        'order' => 'setOrder'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'name' => 'getName',
        'protocol' => 'getProtocol',
        'useTrustStore' => 'getUseTrustStore',
        'host' => 'getHost',
        'port' => 'getPort',
        'searchBase' => 'getSearchBase',
        'authScheme' => 'getAuthScheme',
        'authRealm' => 'getAuthRealm',
        'authUsername' => 'getAuthUsername',
        'connectionTimeoutSeconds' => 'getConnectionTimeoutSeconds',
        'connectionRetryDelaySeconds' => 'getConnectionRetryDelaySeconds',
        'maxIncidentsCount' => 'getMaxIncidentsCount',
        'userBaseDn' => 'getUserBaseDn',
        'userSubtree' => 'getUserSubtree',
        'userObjectClass' => 'getUserObjectClass',
        'userLdapFilter' => 'getUserLdapFilter',
        'userIdAttribute' => 'getUserIdAttribute',
        'userRealNameAttribute' => 'getUserRealNameAttribute',
        'userEmailAddressAttribute' => 'getUserEmailAddressAttribute',
        'userPasswordAttribute' => 'getUserPasswordAttribute',
        'ldapGroupsAsRoles' => 'getLdapGroupsAsRoles',
        'groupType' => 'getGroupType',
        'groupBaseDn' => 'getGroupBaseDn',
        'groupSubtree' => 'getGroupSubtree',
        'groupObjectClass' => 'getGroupObjectClass',
        'groupIdAttribute' => 'getGroupIdAttribute',
        'groupMemberAttribute' => 'getGroupMemberAttribute',
        'groupMemberFormat' => 'getGroupMemberFormat',
        'userMemberOfAttribute' => 'getUserMemberOfAttribute',
        'id' => 'getId',
        'order' => 'getOrder'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const PROTOCOL_LDAP = 'ldap';
    const PROTOCOL_LDAPS = 'ldaps';
    const AUTH_SCHEME_NONE = 'NONE';
    const AUTH_SCHEME_SIMPLE = 'SIMPLE';
    const AUTH_SCHEME_DIGEST_MD5 = 'DIGEST_MD5';
    const AUTH_SCHEME_CRAM_MD5 = 'CRAM_MD5';
    const GROUP_TYPE__STATIC = 'static';
    const GROUP_TYPE_DYNAMIC = 'dynamic';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getProtocolAllowableValues()
    {
        return [
            self::PROTOCOL_LDAP,
            self::PROTOCOL_LDAPS,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getAuthSchemeAllowableValues()
    {
        return [
            self::AUTH_SCHEME_NONE,
            self::AUTH_SCHEME_SIMPLE,
            self::AUTH_SCHEME_DIGEST_MD5,
            self::AUTH_SCHEME_CRAM_MD5,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getGroupTypeAllowableValues()
    {
        return [
            self::GROUP_TYPE__STATIC,
            self::GROUP_TYPE_DYNAMIC,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['name'] = isset($data['name']) ? $data['name'] : null;
        $this->container['protocol'] = isset($data['protocol']) ? $data['protocol'] : null;
        $this->container['useTrustStore'] = isset($data['useTrustStore']) ? $data['useTrustStore'] : null;
        $this->container['host'] = isset($data['host']) ? $data['host'] : null;
        $this->container['port'] = isset($data['port']) ? $data['port'] : null;
        $this->container['searchBase'] = isset($data['searchBase']) ? $data['searchBase'] : null;
        $this->container['authScheme'] = isset($data['authScheme']) ? $data['authScheme'] : null;
        $this->container['authRealm'] = isset($data['authRealm']) ? $data['authRealm'] : null;
        $this->container['authUsername'] = isset($data['authUsername']) ? $data['authUsername'] : null;
        $this->container['connectionTimeoutSeconds'] = isset($data['connectionTimeoutSeconds']) ? $data['connectionTimeoutSeconds'] : null;
        $this->container['connectionRetryDelaySeconds'] = isset($data['connectionRetryDelaySeconds']) ? $data['connectionRetryDelaySeconds'] : null;
        $this->container['maxIncidentsCount'] = isset($data['maxIncidentsCount']) ? $data['maxIncidentsCount'] : null;
        $this->container['userBaseDn'] = isset($data['userBaseDn']) ? $data['userBaseDn'] : null;
        $this->container['userSubtree'] = isset($data['userSubtree']) ? $data['userSubtree'] : null;
        $this->container['userObjectClass'] = isset($data['userObjectClass']) ? $data['userObjectClass'] : null;
        $this->container['userLdapFilter'] = isset($data['userLdapFilter']) ? $data['userLdapFilter'] : null;
        $this->container['userIdAttribute'] = isset($data['userIdAttribute']) ? $data['userIdAttribute'] : null;
        $this->container['userRealNameAttribute'] = isset($data['userRealNameAttribute']) ? $data['userRealNameAttribute'] : null;
        $this->container['userEmailAddressAttribute'] = isset($data['userEmailAddressAttribute']) ? $data['userEmailAddressAttribute'] : null;
        $this->container['userPasswordAttribute'] = isset($data['userPasswordAttribute']) ? $data['userPasswordAttribute'] : null;
        $this->container['ldapGroupsAsRoles'] = isset($data['ldapGroupsAsRoles']) ? $data['ldapGroupsAsRoles'] : null;
        $this->container['groupType'] = isset($data['groupType']) ? $data['groupType'] : null;
        $this->container['groupBaseDn'] = isset($data['groupBaseDn']) ? $data['groupBaseDn'] : null;
        $this->container['groupSubtree'] = isset($data['groupSubtree']) ? $data['groupSubtree'] : null;
        $this->container['groupObjectClass'] = isset($data['groupObjectClass']) ? $data['groupObjectClass'] : null;
        $this->container['groupIdAttribute'] = isset($data['groupIdAttribute']) ? $data['groupIdAttribute'] : null;
        $this->container['groupMemberAttribute'] = isset($data['groupMemberAttribute']) ? $data['groupMemberAttribute'] : null;
        $this->container['groupMemberFormat'] = isset($data['groupMemberFormat']) ? $data['groupMemberFormat'] : null;
        $this->container['userMemberOfAttribute'] = isset($data['userMemberOfAttribute']) ? $data['userMemberOfAttribute'] : null;
        $this->container['id'] = isset($data['id']) ? $data['id'] : null;
        $this->container['order'] = isset($data['order']) ? $data['order'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['name'] === null) {
            $invalidProperties[] = "'name' can't be null";
        }
        if ($this->container['protocol'] === null) {
            $invalidProperties[] = "'protocol' can't be null";
        }
        $allowedValues = $this->getProtocolAllowableValues();
        if (!is_null($this->container['protocol']) && !in_array($this->container['protocol'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'protocol', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['host'] === null) {
            $invalidProperties[] = "'host' can't be null";
        }
        if ($this->container['port'] === null) {
            $invalidProperties[] = "'port' can't be null";
        }
        if ($this->container['searchBase'] === null) {
            $invalidProperties[] = "'searchBase' can't be null";
        }
        if ($this->container['authScheme'] === null) {
            $invalidProperties[] = "'authScheme' can't be null";
        }
        $allowedValues = $this->getAuthSchemeAllowableValues();
        if (!is_null($this->container['authScheme']) && !in_array($this->container['authScheme'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'authScheme', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['connectionTimeoutSeconds'] === null) {
            $invalidProperties[] = "'connectionTimeoutSeconds' can't be null";
        }
        if (($this->container['connectionTimeoutSeconds'] > 3600)) {
            $invalidProperties[] = "invalid value for 'connectionTimeoutSeconds', must be smaller than or equal to 3600.";
        }

        if (($this->container['connectionTimeoutSeconds'] < 1)) {
            $invalidProperties[] = "invalid value for 'connectionTimeoutSeconds', must be bigger than or equal to 1.";
        }

        if ($this->container['connectionRetryDelaySeconds'] === null) {
            $invalidProperties[] = "'connectionRetryDelaySeconds' can't be null";
        }
        if (($this->container['connectionRetryDelaySeconds'] < 0)) {
            $invalidProperties[] = "invalid value for 'connectionRetryDelaySeconds', must be bigger than or equal to 0.";
        }

        if ($this->container['maxIncidentsCount'] === null) {
            $invalidProperties[] = "'maxIncidentsCount' can't be null";
        }
        if (($this->container['maxIncidentsCount'] < 0)) {
            $invalidProperties[] = "invalid value for 'maxIncidentsCount', must be bigger than or equal to 0.";
        }

        if ($this->container['groupType'] === null) {
            $invalidProperties[] = "'groupType' can't be null";
        }
        $allowedValues = $this->getGroupTypeAllowableValues();
        if (!is_null($this->container['groupType']) && !in_array($this->container['groupType'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'groupType', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['groupObjectClass']) && (mb_strlen($this->container['groupObjectClass']) > 0)) {
            $invalidProperties[] = "invalid value for 'groupObjectClass', the character length must be smaller than or equal to 0.";
        }

        if (!is_null($this->container['groupObjectClass']) && (mb_strlen($this->container['groupObjectClass']) < 0)) {
            $invalidProperties[] = "invalid value for 'groupObjectClass', the character length must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['groupIdAttribute']) && (mb_strlen($this->container['groupIdAttribute']) > 0)) {
            $invalidProperties[] = "invalid value for 'groupIdAttribute', the character length must be smaller than or equal to 0.";
        }

        if (!is_null($this->container['groupIdAttribute']) && (mb_strlen($this->container['groupIdAttribute']) < 0)) {
            $invalidProperties[] = "invalid value for 'groupIdAttribute', the character length must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['groupMemberAttribute']) && (mb_strlen($this->container['groupMemberAttribute']) > 0)) {
            $invalidProperties[] = "invalid value for 'groupMemberAttribute', the character length must be smaller than or equal to 0.";
        }

        if (!is_null($this->container['groupMemberAttribute']) && (mb_strlen($this->container['groupMemberAttribute']) < 0)) {
            $invalidProperties[] = "invalid value for 'groupMemberAttribute', the character length must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['groupMemberFormat']) && (mb_strlen($this->container['groupMemberFormat']) > 0)) {
            $invalidProperties[] = "invalid value for 'groupMemberFormat', the character length must be smaller than or equal to 0.";
        }

        if (!is_null($this->container['groupMemberFormat']) && (mb_strlen($this->container['groupMemberFormat']) < 0)) {
            $invalidProperties[] = "invalid value for 'groupMemberFormat', the character length must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['userMemberOfAttribute']) && (mb_strlen($this->container['userMemberOfAttribute']) > 0)) {
            $invalidProperties[] = "invalid value for 'userMemberOfAttribute', the character length must be smaller than or equal to 0.";
        }

        if (!is_null($this->container['userMemberOfAttribute']) && (mb_strlen($this->container['userMemberOfAttribute']) < 0)) {
            $invalidProperties[] = "invalid value for 'userMemberOfAttribute', the character length must be bigger than or equal to 0.";
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets name
     *
     * @return string
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string $name LDAP server name
     *
     * @return $this
     */
    public function setName($name)
    {
        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets protocol
     *
     * @return string
     */
    public function getProtocol()
    {
        return $this->container['protocol'];
    }

    /**
     * Sets protocol
     *
     * @param string $protocol LDAP server connection Protocol to use
     *
     * @return $this
     */
    public function setProtocol($protocol)
    {
        $allowedValues = $this->getProtocolAllowableValues();
        if (!in_array($protocol, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'protocol', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['protocol'] = $protocol;

        return $this;
    }

    /**
     * Gets useTrustStore
     *
     * @return bool
     */
    public function getUseTrustStore()
    {
        return $this->container['useTrustStore'];
    }

    /**
     * Sets useTrustStore
     *
     * @param bool $useTrustStore Whether to use certificates stored in Nexus Repository Manager's truststore
     *
     * @return $this
     */
    public function setUseTrustStore($useTrustStore)
    {
        $this->container['useTrustStore'] = $useTrustStore;

        return $this;
    }

    /**
     * Gets host
     *
     * @return string
     */
    public function getHost()
    {
        return $this->container['host'];
    }

    /**
     * Sets host
     *
     * @param string $host LDAP server connection hostname
     *
     * @return $this
     */
    public function setHost($host)
    {
        $this->container['host'] = $host;

        return $this;
    }

    /**
     * Gets port
     *
     * @return int
     */
    public function getPort()
    {
        return $this->container['port'];
    }

    /**
     * Sets port
     *
     * @param int $port LDAP server connection port to use
     *
     * @return $this
     */
    public function setPort($port)
    {
        $this->container['port'] = $port;

        return $this;
    }

    /**
     * Gets searchBase
     *
     * @return string
     */
    public function getSearchBase()
    {
        return $this->container['searchBase'];
    }

    /**
     * Sets searchBase
     *
     * @param string $searchBase LDAP location to be added to the connection URL
     *
     * @return $this
     */
    public function setSearchBase($searchBase)
    {
        $this->container['searchBase'] = $searchBase;

        return $this;
    }

    /**
     * Gets authScheme
     *
     * @return string
     */
    public function getAuthScheme()
    {
        return $this->container['authScheme'];
    }

    /**
     * Sets authScheme
     *
     * @param string $authScheme Authentication scheme used for connecting to LDAP server
     *
     * @return $this
     */
    public function setAuthScheme($authScheme)
    {
        $allowedValues = $this->getAuthSchemeAllowableValues();
        if (!in_array($authScheme, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'authScheme', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['authScheme'] = $authScheme;

        return $this;
    }

    /**
     * Gets authRealm
     *
     * @return string
     */
    public function getAuthRealm()
    {
        return $this->container['authRealm'];
    }

    /**
     * Sets authRealm
     *
     * @param string $authRealm The SASL realm to bind to. Required if authScheme is CRAM_MD5 or DIGEST_MD5
     *
     * @return $this
     */
    public function setAuthRealm($authRealm)
    {
        $this->container['authRealm'] = $authRealm;

        return $this;
    }

    /**
     * Gets authUsername
     *
     * @return string
     */
    public function getAuthUsername()
    {
        return $this->container['authUsername'];
    }

    /**
     * Sets authUsername
     *
     * @param string $authUsername This must be a fully qualified username if simple authentication is used. Required if authScheme other than none.
     *
     * @return $this
     */
    public function setAuthUsername($authUsername)
    {
        $this->container['authUsername'] = $authUsername;

        return $this;
    }

    /**
     * Gets connectionTimeoutSeconds
     *
     * @return int
     */
    public function getConnectionTimeoutSeconds()
    {
        return $this->container['connectionTimeoutSeconds'];
    }

    /**
     * Sets connectionTimeoutSeconds
     *
     * @param int $connectionTimeoutSeconds How long to wait before timeout
     *
     * @return $this
     */
    public function setConnectionTimeoutSeconds($connectionTimeoutSeconds)
    {

        if (($connectionTimeoutSeconds > 3600)) {
            throw new \InvalidArgumentException('invalid value for $connectionTimeoutSeconds when calling ReadLdapServerXo., must be smaller than or equal to 3600.');
        }
        if (($connectionTimeoutSeconds < 1)) {
            throw new \InvalidArgumentException('invalid value for $connectionTimeoutSeconds when calling ReadLdapServerXo., must be bigger than or equal to 1.');
        }

        $this->container['connectionTimeoutSeconds'] = $connectionTimeoutSeconds;

        return $this;
    }

    /**
     * Gets connectionRetryDelaySeconds
     *
     * @return int
     */
    public function getConnectionRetryDelaySeconds()
    {
        return $this->container['connectionRetryDelaySeconds'];
    }

    /**
     * Sets connectionRetryDelaySeconds
     *
     * @param int $connectionRetryDelaySeconds How long to wait before retrying
     *
     * @return $this
     */
    public function setConnectionRetryDelaySeconds($connectionRetryDelaySeconds)
    {

        if (($connectionRetryDelaySeconds < 0)) {
            throw new \InvalidArgumentException('invalid value for $connectionRetryDelaySeconds when calling ReadLdapServerXo., must be bigger than or equal to 0.');
        }

        $this->container['connectionRetryDelaySeconds'] = $connectionRetryDelaySeconds;

        return $this;
    }

    /**
     * Gets maxIncidentsCount
     *
     * @return int
     */
    public function getMaxIncidentsCount()
    {
        return $this->container['maxIncidentsCount'];
    }

    /**
     * Sets maxIncidentsCount
     *
     * @param int $maxIncidentsCount How many retry attempts
     *
     * @return $this
     */
    public function setMaxIncidentsCount($maxIncidentsCount)
    {

        if (($maxIncidentsCount < 0)) {
            throw new \InvalidArgumentException('invalid value for $maxIncidentsCount when calling ReadLdapServerXo., must be bigger than or equal to 0.');
        }

        $this->container['maxIncidentsCount'] = $maxIncidentsCount;

        return $this;
    }

    /**
     * Gets userBaseDn
     *
     * @return string
     */
    public function getUserBaseDn()
    {
        return $this->container['userBaseDn'];
    }

    /**
     * Sets userBaseDn
     *
     * @param string $userBaseDn The relative DN where user objects are found (e.g. ou=people). This value will have the Search base DN value appended to form the full User search base DN.
     *
     * @return $this
     */
    public function setUserBaseDn($userBaseDn)
    {
        $this->container['userBaseDn'] = $userBaseDn;

        return $this;
    }

    /**
     * Gets userSubtree
     *
     * @return bool
     */
    public function getUserSubtree()
    {
        return $this->container['userSubtree'];
    }

    /**
     * Sets userSubtree
     *
     * @param bool $userSubtree Are users located in structures below the user base DN?
     *
     * @return $this
     */
    public function setUserSubtree($userSubtree)
    {
        $this->container['userSubtree'] = $userSubtree;

        return $this;
    }

    /**
     * Gets userObjectClass
     *
     * @return string
     */
    public function getUserObjectClass()
    {
        return $this->container['userObjectClass'];
    }

    /**
     * Sets userObjectClass
     *
     * @param string $userObjectClass LDAP class for user objects
     *
     * @return $this
     */
    public function setUserObjectClass($userObjectClass)
    {
        $this->container['userObjectClass'] = $userObjectClass;

        return $this;
    }

    /**
     * Gets userLdapFilter
     *
     * @return string
     */
    public function getUserLdapFilter()
    {
        return $this->container['userLdapFilter'];
    }

    /**
     * Sets userLdapFilter
     *
     * @param string $userLdapFilter LDAP search filter to limit user search
     *
     * @return $this
     */
    public function setUserLdapFilter($userLdapFilter)
    {
        $this->container['userLdapFilter'] = $userLdapFilter;

        return $this;
    }

    /**
     * Gets userIdAttribute
     *
     * @return string
     */
    public function getUserIdAttribute()
    {
        return $this->container['userIdAttribute'];
    }

    /**
     * Sets userIdAttribute
     *
     * @param string $userIdAttribute This is used to find a user given its user ID
     *
     * @return $this
     */
    public function setUserIdAttribute($userIdAttribute)
    {
        $this->container['userIdAttribute'] = $userIdAttribute;

        return $this;
    }

    /**
     * Gets userRealNameAttribute
     *
     * @return string
     */
    public function getUserRealNameAttribute()
    {
        return $this->container['userRealNameAttribute'];
    }

    /**
     * Sets userRealNameAttribute
     *
     * @param string $userRealNameAttribute This is used to find a real name given the user ID
     *
     * @return $this
     */
    public function setUserRealNameAttribute($userRealNameAttribute)
    {
        $this->container['userRealNameAttribute'] = $userRealNameAttribute;

        return $this;
    }

    /**
     * Gets userEmailAddressAttribute
     *
     * @return string
     */
    public function getUserEmailAddressAttribute()
    {
        return $this->container['userEmailAddressAttribute'];
    }

    /**
     * Sets userEmailAddressAttribute
     *
     * @param string $userEmailAddressAttribute This is used to find an email address given the user ID
     *
     * @return $this
     */
    public function setUserEmailAddressAttribute($userEmailAddressAttribute)
    {
        $this->container['userEmailAddressAttribute'] = $userEmailAddressAttribute;

        return $this;
    }

    /**
     * Gets userPasswordAttribute
     *
     * @return string
     */
    public function getUserPasswordAttribute()
    {
        return $this->container['userPasswordAttribute'];
    }

    /**
     * Sets userPasswordAttribute
     *
     * @param string $userPasswordAttribute If this field is blank the user will be authenticated against a bind with the LDAP server
     *
     * @return $this
     */
    public function setUserPasswordAttribute($userPasswordAttribute)
    {
        $this->container['userPasswordAttribute'] = $userPasswordAttribute;

        return $this;
    }

    /**
     * Gets ldapGroupsAsRoles
     *
     * @return bool
     */
    public function getLdapGroupsAsRoles()
    {
        return $this->container['ldapGroupsAsRoles'];
    }

    /**
     * Sets ldapGroupsAsRoles
     *
     * @param bool $ldapGroupsAsRoles Denotes whether LDAP assigned roles are used as Nexus Repository Manager roles
     *
     * @return $this
     */
    public function setLdapGroupsAsRoles($ldapGroupsAsRoles)
    {
        $this->container['ldapGroupsAsRoles'] = $ldapGroupsAsRoles;

        return $this;
    }

    /**
     * Gets groupType
     *
     * @return string
     */
    public function getGroupType()
    {
        return $this->container['groupType'];
    }

    /**
     * Sets groupType
     *
     * @param string $groupType Defines a type of groups used: static (a group contains a list of users) or dynamic (a user contains a list of groups). Required if ldapGroupsAsRoles is true.
     *
     * @return $this
     */
    public function setGroupType($groupType)
    {
        $allowedValues = $this->getGroupTypeAllowableValues();
        if (!in_array($groupType, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'groupType', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['groupType'] = $groupType;

        return $this;
    }

    /**
     * Gets groupBaseDn
     *
     * @return string
     */
    public function getGroupBaseDn()
    {
        return $this->container['groupBaseDn'];
    }

    /**
     * Sets groupBaseDn
     *
     * @param string $groupBaseDn The relative DN where group objects are found (e.g. ou=Group). This value will have the Search base DN value appended to form the full Group search base DN.
     *
     * @return $this
     */
    public function setGroupBaseDn($groupBaseDn)
    {
        $this->container['groupBaseDn'] = $groupBaseDn;

        return $this;
    }

    /**
     * Gets groupSubtree
     *
     * @return bool
     */
    public function getGroupSubtree()
    {
        return $this->container['groupSubtree'];
    }

    /**
     * Sets groupSubtree
     *
     * @param bool $groupSubtree Are groups located in structures below the group base DN
     *
     * @return $this
     */
    public function setGroupSubtree($groupSubtree)
    {
        $this->container['groupSubtree'] = $groupSubtree;

        return $this;
    }

    /**
     * Gets groupObjectClass
     *
     * @return string
     */
    public function getGroupObjectClass()
    {
        return $this->container['groupObjectClass'];
    }

    /**
     * Sets groupObjectClass
     *
     * @param string $groupObjectClass LDAP class for group objects. Required if groupType is static
     *
     * @return $this
     */
    public function setGroupObjectClass($groupObjectClass)
    {
        if (!is_null($groupObjectClass) && (mb_strlen($groupObjectClass) > 0)) {
            throw new \InvalidArgumentException('invalid length for $groupObjectClass when calling ReadLdapServerXo., must be smaller than or equal to 0.');
        }
        if (!is_null($groupObjectClass) && (mb_strlen($groupObjectClass) < 0)) {
            throw new \InvalidArgumentException('invalid length for $groupObjectClass when calling ReadLdapServerXo., must be bigger than or equal to 0.');
        }

        $this->container['groupObjectClass'] = $groupObjectClass;

        return $this;
    }

    /**
     * Gets groupIdAttribute
     *
     * @return string
     */
    public function getGroupIdAttribute()
    {
        return $this->container['groupIdAttribute'];
    }

    /**
     * Sets groupIdAttribute
     *
     * @param string $groupIdAttribute This field specifies the attribute of the Object class that defines the Group ID. Required if groupType is static
     *
     * @return $this
     */
    public function setGroupIdAttribute($groupIdAttribute)
    {
        if (!is_null($groupIdAttribute) && (mb_strlen($groupIdAttribute) > 0)) {
            throw new \InvalidArgumentException('invalid length for $groupIdAttribute when calling ReadLdapServerXo., must be smaller than or equal to 0.');
        }
        if (!is_null($groupIdAttribute) && (mb_strlen($groupIdAttribute) < 0)) {
            throw new \InvalidArgumentException('invalid length for $groupIdAttribute when calling ReadLdapServerXo., must be bigger than or equal to 0.');
        }

        $this->container['groupIdAttribute'] = $groupIdAttribute;

        return $this;
    }

    /**
     * Gets groupMemberAttribute
     *
     * @return string
     */
    public function getGroupMemberAttribute()
    {
        return $this->container['groupMemberAttribute'];
    }

    /**
     * Sets groupMemberAttribute
     *
     * @param string $groupMemberAttribute LDAP attribute containing the usernames for the group. Required if groupType is static
     *
     * @return $this
     */
    public function setGroupMemberAttribute($groupMemberAttribute)
    {
        if (!is_null($groupMemberAttribute) && (mb_strlen($groupMemberAttribute) > 0)) {
            throw new \InvalidArgumentException('invalid length for $groupMemberAttribute when calling ReadLdapServerXo., must be smaller than or equal to 0.');
        }
        if (!is_null($groupMemberAttribute) && (mb_strlen($groupMemberAttribute) < 0)) {
            throw new \InvalidArgumentException('invalid length for $groupMemberAttribute when calling ReadLdapServerXo., must be bigger than or equal to 0.');
        }

        $this->container['groupMemberAttribute'] = $groupMemberAttribute;

        return $this;
    }

    /**
     * Gets groupMemberFormat
     *
     * @return string
     */
    public function getGroupMemberFormat()
    {
        return $this->container['groupMemberFormat'];
    }

    /**
     * Sets groupMemberFormat
     *
     * @param string $groupMemberFormat The format of user ID stored in the group member attribute. Required if groupType is static
     *
     * @return $this
     */
    public function setGroupMemberFormat($groupMemberFormat)
    {
        if (!is_null($groupMemberFormat) && (mb_strlen($groupMemberFormat) > 0)) {
            throw new \InvalidArgumentException('invalid length for $groupMemberFormat when calling ReadLdapServerXo., must be smaller than or equal to 0.');
        }
        if (!is_null($groupMemberFormat) && (mb_strlen($groupMemberFormat) < 0)) {
            throw new \InvalidArgumentException('invalid length for $groupMemberFormat when calling ReadLdapServerXo., must be bigger than or equal to 0.');
        }

        $this->container['groupMemberFormat'] = $groupMemberFormat;

        return $this;
    }

    /**
     * Gets userMemberOfAttribute
     *
     * @return string
     */
    public function getUserMemberOfAttribute()
    {
        return $this->container['userMemberOfAttribute'];
    }

    /**
     * Sets userMemberOfAttribute
     *
     * @param string $userMemberOfAttribute Set this to the attribute used to store the attribute which holds groups DN in the user object. Required if groupType is dynamic
     *
     * @return $this
     */
    public function setUserMemberOfAttribute($userMemberOfAttribute)
    {
        if (!is_null($userMemberOfAttribute) && (mb_strlen($userMemberOfAttribute) > 0)) {
            throw new \InvalidArgumentException('invalid length for $userMemberOfAttribute when calling ReadLdapServerXo., must be smaller than or equal to 0.');
        }
        if (!is_null($userMemberOfAttribute) && (mb_strlen($userMemberOfAttribute) < 0)) {
            throw new \InvalidArgumentException('invalid length for $userMemberOfAttribute when calling ReadLdapServerXo., must be bigger than or equal to 0.');
        }

        $this->container['userMemberOfAttribute'] = $userMemberOfAttribute;

        return $this;
    }

    /**
     * Gets id
     *
     * @return string
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param string $id LDAP server ID
     *
     * @return $this
     */
    public function setId($id)
    {
        $this->container['id'] = $id;

        return $this;
    }

    /**
     * Gets order
     *
     * @return int
     */
    public function getOrder()
    {
        return $this->container['order'];
    }

    /**
     * Sets order
     *
     * @param int $order Order number in which the server is being used when looking for a user
     *
     * @return $this
     */
    public function setOrder($order)
    {
        $this->container['order'] = $order;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    #[\ReturnTypeWillChange]
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    #[\ReturnTypeWillChange]
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    #[\ReturnTypeWillChange]
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


